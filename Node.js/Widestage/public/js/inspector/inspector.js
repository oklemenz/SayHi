angular.module('wst.inspector', [])

.factory('textStyles', function(){
	return {
		fontSizes: [8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72],
		fontWeights: [100, 200, 300, 400, 500, 600, 700, 800, 900, 'bold', 'bolder', 'light', 'lighter', 'normal'],
		baseFonts: [
			{name: 'Impact', css: 'Impact, Charcoal, sans-serif'},
			{name: 'Comic Sans', css: '"Comic Sans MS", cursive, sans-serif'},
			{name: 'Arial Black', css: '"Arial Black", Gadget, sans-serif'},
			{name: 'Century Gothic', css: 'Century Gothic, sans-serif'},
			{name: 'Courier New', css: '"Courier New", Courier, monospace'},
			{name: 'Lucida Sans', css: '"Lucida Sans Unicode", "Lucida Grande", sans-serif'},
			{name: 'Times New Roman', css: '"Times New Roman", Times, serif'},
			{name: 'Lucida Console', css: '"Lucida Console", Monaco, monospace'},
			{name: 'Andele Mono', css: '"Andele Mono", monospace, sans-serif'},
			{name: 'Verdana', css: 'Verdana, Geneva, sans-serif'},
			{name: 'Helvetica Neue', css: '"Helvetica Neue", Helvetica, Arial, sans-serif'},
      {name: 'Open Sans', css:'"Open Sans", Helvetica, Arial, sans-serif'}
		]
	};
})

.factory('css', ['$rootScope', function($rootScope) {


	var css = {

		rules: {},

		sheet: null,

		/**
		 * Parse css into basic js object.
		 *
		 * @param  string css
		 * @return object
		 */
		cssToObject: function(css) {
			var obj = {};

			if (css) {

				//remove comments
				var stripped = css.replace(/\/\*!(.|\n)+?\*\//, '');

				//split css into selector - rules blocks
	        	var blocks = stripped.split('}\n');

	            for (var i = blocks.length - 1; i >= 0; i--) {

	                //trim whitespace from sides
	                var block = (blocks[i]).trim();

	                //match selector
	                var sel = block.match(/([^]+){/);

	                if (sel) {
	                	sel = sel[1].trim();

	                	//assign new object to selector if doesn't exist yet
	                	if ( ! obj[sel]) {
	                		obj[sel] = {};
	                	}

	                	//split this blocks rules into an array ['padding:10px']
	                    var rules = block.replace(sel, '').replace(/{|}/g, '').trim().split(';');

	                    for (var ind = 0; ind < rules.length; ind++) {
	                        var rule = rules[ind];

	                        if (rule) {

	                        	//split rule into name = value pairs
	                            var split = rule.split(/:(.+)?/);

	                            //if name and value seem valid assign them to the object
	                            if ((split[0] && split[0].length > 1) && (split[1] && split[1].replace(/\s|;/g, '').length > 0)) {
	                                obj[sel][split[0].trim()] = split[1].trim();
	                            }
	                        }
	                    };
	                }
	            };
	        }

	        return obj;
		},

		/**
		 * Compile custom user css and css generated by the
		 * builder itself into a single formatted string.
		 *
		 * @return string
		 */
		compile: function() {
			var css = '',
				obj = $.extend(true, {}, this.rules);

			for (var selector in obj) {
				css += selector + ' {\n'
				for (var rule in obj[selector]) {
					if (rule.indexOf('_') !== 0) {
						css += '    ' + rule + ': ' + obj[selector][rule] + ";\n";
					}
				}

				css += "}\n\n";
			}

			var compiled = css+$rootScope.customCss.html().replace(/\/\*!(.|\n)+?\*\//, '').trim();

			return compiled;
		},

		/**
		 * Replace all relative urls to absolute in given css string.
		 *
		 * @param  string css
		 * @return string
		 */
		relativeToAbsolute: function(css) {
			if ( ! css) { return ''; };
			return css.replace(/url\((?!http)\.?\.?(.+?)\)/g, 'url('+$rootScope.baseUrl+'$1)');
		},

		/**
		 * Format given selector to a string.
		 *
		 * @param  mixed selector
		 * @return string
		 */
		formatSelector: function(selector) {
			var hadDynamicClasses = false;

			if ( ! selector) {
				selector = $rootScope.selected.selector;
			}

			//if we're passed an array of element parents as selector
			//we'll need to parse that to a string first
			if (angular.isArray(selector)) {
				var mapped = $.map(selector, function(obj) {

					//if it's a string just return it
					if (angular.isString(obj)) {
						return obj;

					//if not we'll need to use node class, id or name
					} else {

						//if node has an id return that
						if (obj.node.id) {
							return '#'+obj.node.id;

						//next try to get a class
						} else if (obj.node.className) {
							var c = obj.node.className.split(' ');

							//return the longest class as that one is most likely to be unique
							return '.'+c.reduce(function (a, b) { return a.length > b.length ? a : b; });

						//lastly use node name if nothing else is available
						} else {
							return obj.node.nodeName.toLowerCase();
						}
					}
				});

				return mapped.join(' > ');
			}

			return selector;
		},

		remove: function(selector, style) {
			var sel  = this.formatSelector(selector),
				style = style.toDashedCase();

			if (this.sheet && this.rules && this.rules[sel]) {
				this.rules[sel][style] = null;
				this.rules[sel]._cssObject.style[style] = 'initial';
			}
		},

		/**
		 * Compile css styles object into shorthand string.
		 *
		 * @param  object o
		 * @return string
		 */
		objectToString: function(o) {
			//compiling border radius
			if (o.topLeft) {
				return o.topLeft+' '+o.topRight+' '+o.bottomRight+' '+o.bottomLeft;

			//compiling everything else
			} else {
				return o.top+' '+o.right+' '+o.bottom+' '+o.left;
			}
		},

		/**
		 * Load given css into iframe.
		 *
		 * @param  string cssString
		 * @return {void}
		 */
		loadCss: function(cssString) {

			var editorCss = $rootScope.frameHead.find('#editor-css');

			//clear current css
			editorCss.html('');

			//load given css
			editorCss.append("\n"+cssString);
		},

		getValueFor: function(selector, style) {
			var ruleStack = this.rules[selector];

			if (ruleStack && ruleStack[style]) {
				return ruleStack[style];
			}

			return $rootScope.selected.getStyle(style);
		},

		add: function(selector, style, value, oldValue, noEvent) {

			if ( ! this.sheet) {
				this.sheet = $('<style id="inspector-css"></style>').appendTo($rootScope.frameHead)[0].sheet;
			}

			if (selector) {
				selector = this.formatSelector(selector);
			} else {
				selector = $rootScope.selected.selector;
			}

			//if style is an object then wel'll need to loop
			//trough it and call this method for each property
			if (angular.isObject(style)) {
				for (var prop in style) {
					this.add(selector, prop, style[prop]);
				}
			}

			if (angular.isObject(value)) {
				value = this.objectToString(value);
			}

			//cache the css rules object for this selector
			var ruleStack = this.rules[selector];

			if (ruleStack) {
				//add new value to cached cssRule object, this
				//will instantly reflect new css style in the DOM
			 	ruleStack._cssObject.style[style.toCamelCase()] = value;

			 	//store new value in our custom css object
			 	ruleStack[style.toDashedCase()] = value;
			} else {
				//create and cache css rules object for this selector
				var ruleStack = this.rules[selector] = {};

				//add new style to our custom css object
				ruleStack[style.toDashedCase()] = value;

				//insert new style as a rule into iframe styleSheets object
				//so it's reflected in the DOM instantly
				this.sheet.insertRule(selector+'{'+style+':'+value+';}', 0);

				//cache the cssRule object so we can modify it later instead
				//of creating a ton of new rules and eating up the memory
				ruleStack._cssObject = this.sheet.cssRules[0];
			}

			if ( ! noEvent) {
				$rootScope.$broadcast('builder.css.changed');
			}
		},
	};

	return css;
}])

.factory('undoManager', ['$rootScope', '$timeout', 'css', function($rootScope, $timeout, css) {

	var manager = {

		/**
		 * Stack of undo/redo commands.
		 *
		 * @type {Array}
		 */
		commands: [],

		/**
		 * Current position of pointer in undo/redo stack.
		 *
		 * @type {Number}
		 */
		pointer: -1,

		/**
		 * Whether or not there's any undos left in the stack.
		 *
		 * @type {Boolean}
		 */
		canUndo: false,

		/**
		 * Whether or not there's any redos left in the stack.
		 *
		 * @type {Boolean}
		 */
		canRedo: false,

		/**
		 * Whether or not there's any undos left in the stack.
		 *
		 * @return {Boolean}
		 */
		hasUndo: function () {
            return this.pointer !== -1;
        },

        /**
		 * Whether or not there's any redos left in the stack.
		 *
		 * @return {Boolean}
		 */
        hasRedo: function () {
            return this.pointer < (this.commands.length - 1);
        },

        updateStatuses: function() {
        	this.canUndo = this.hasUndo();
        	this.canRedo = this.hasRedo();
        },

		/**
		 * Execute undo function of command at current pointers position in stack.
		 *
		 * @return void
		 */
		undo: function() {
			var command = this.commands[this.pointer];

			if (command) {
				command.undo();
				this.pointer -= 1;
				this.updateStatuses();
			}
		},

		/**
		 * Execute redo function of command at current pointers position in stack.
		 *
		 * @return void
		 */
		redo: function() {
			var command = this.commands[this.pointer + 1];

			if (command) {
				command.redo();
				this.pointer += 1;
				this.updateStatuses();
			}
		},

		/**
		 * Add a new undo/redo command to the stack.
		 *
		 * @param string name     name of the command
		 * @param object params   command parameters
 		 */
		add: function(name, params) {

			//invalidate commands higher on the stack then this one if any exist
			this.commands.splice(this.index + 1, this.commands.length - this.index);

			//make a new command
			var command = new manager[name](params);

			//push it onto the stack
			this.commands.push(command);

			//update pointer position
			this.pointer = this.commands.length - 1;

			//update canUndo/canRedo booleans and prevent
			//apply already in progress errors
			$timeout(function(){
				$rootScope.$apply(function() {
					manager.updateStatuses();
				});
			});

			return command;
		},

		generic: function(params) {
			this.undo = params.undo;
			this.redo = params.redo;
		},

		/**
		 * Command for undoing/redoing dom node reordering.
		 *
		 * @param  object params
		 * @return void
		 */
		reorderElement: function(params) {
			this.params = params;
		},

		/**
		 * Command for undoing/redoing dom node deletion.
		 *
		 * @param  object params
		 * @return void
		 */
		deleteNode: function(params) {
			this.params = params;
		},

		/**
		 * Command for undoing/redoing new dom node insertion.
		 *
		 * @param  object params
		 * @return void
		 */
		insertNode: function(params) {
			this.params = params;
		},

		/**
		 * Command for undoing/redoing new column insertion.
		 *
		 * @param  object params
		 * @return void
		 */
		insertColumn: function(params) {
			this.params = params;
		},

		/**
		 * Command for undoing/redoing element style changes in inspector.
		 *
		 * @param  object params
		 * @return void
		 */
		revertStyles: function(params) {
			this.params = params;
		}
	};

	/**
	 * RevertStyles command undo action.
	 *
	 * @return void
	 */
	manager.revertStyles.prototype.undo = function() {
		css.add(this.params.path, this.params.property, this.params.oldStyles);

		$rootScope.repositionBox('select');
		$rootScope.hoverBox.hide();
	};

	/**
	 * RevertStyles command redo action.
	 *
	 * @return void
	 */
	manager.revertStyles.prototype.redo = function() {

		if (this.params.redoProps) {
			css.add(this.params.path, this.params.redoProps);
		} else {
			css.add(this.params.path, this.params.property, this.params.newStyles);
		}

		$rootScope.repositionBox('select');
		$rootScope.hoverBox.hide();
	};

	/**
	 * DeleteNode command undo action.
	 *
	 * @return void
	 */
	manager.deleteNode.prototype.undo = function() {
		this.insertAtIndex = manager.reorderElement.prototype.insertAtIndex;
		this.insertAtIndex();
	};

	/**
	 * DeleteNode command redo action.
	 *
	 * @return void
	 */
	manager.deleteNode.prototype.redo = function() {
		this.params.node.remove();
		$rootScope.selectBox.hide();
		$rootScope.hoverBox.hide();
	};

	/**
	 * InsertNode command undo action.
	 *
	 * @return void
	 */
	manager.insertNode.prototype.undo = function() {
		if (this.params.node) {
			$(this.params.node).remove();
			$rootScope.selectBox.hide();
			$rootScope.hoverBox.hide();
		}
	};

	manager.insertColumn.prototype.undo = function() {
		this.params.node.remove();
		this.params.resize(this.params.oldNode, '+', 1);

		$rootScope.selectBox.hide();
		$rootScope.hoverBox.hide();
	};

	manager.insertColumn.prototype.redo = function() {
		this.insertAtIndex = manager.reorderElement.prototype.insertAtIndex;
		this.insertAtIndex();
		this.params.resize(this.params.oldNode, '-', 1);
	};

	/**
	 * InsertNode command redo action.
	 *
	 * @return void
	 */
	manager.insertNode.prototype.redo = function() {
		this.insertAtIndex = manager.reorderElement.prototype.insertAtIndex;
		this.insertAtIndex();
	};

	/**
	 * reorderElement command undo action.
	 *
	 * @return void
	 */
	manager.reorderElement.prototype.undo = function() {
		this.insertAtIndex('undo');
	};

	/**
	 * reorderElement command redo action.
	 *
	 * @return void
	 */
	manager.reorderElement.prototype.redo = function() {
		this.insertAtIndex('redo');
	};

	/**
	 * Insert node at given index in the parent.
	 *
	 * @param  string type   prepend or append
	 * @return void
	 */
	manager.reorderElement.prototype.insertAtIndex = function(type) {
		var before = true, parent = $(this.params.parent);

		//we'll need to use different index if we're undoing or redoing the insert
		var index = type == 'redo' ? this.params.redoIndex : this.params.undoIndex;

		//if index is zero just prepend node to parent
		if (index === 0) {
			parent.prepend(this.params.node);
		}

		//if index is higher then parent has children just append node to parent
		else if (index+1 >= this.params.parentContents.length) {
			parent.append(this.params.node);
		}
		else {
			var contents = parent.contents(),
				currentIndex = contents.index(this.params.node);

			//if node doesn't exist in the parent contents always insert
			//it before the index otherwise do it depending on the index difference
			before = currentIndex == -1 ? true : currentIndex > index;

			//loop trough the parent contents and when index matches
			//prepend or append node to the node current at that index
			for (var i = contents.length - 1; i >= 0; i--) {
				if (i === index) {
	    			if (before) {
	    				return $(contents[i]).before(this.params.node);
	    			} else {
	    				return $(contents[i]).after(this.params.node);
	    			}
	    		}
			}
		}

		$rootScope.repositionBox('select');
	};

	//MENE builder.undo = manager.commands;

	return manager;
}])

.factory('inspector', ['$rootScope', 'css', 'undoManager', function($rootScope, css, undoManager) {

	var inspector = {

		/**
		 * Whether or not user is currently using range slider.
		 *
		 * @type {Boolean}
		 */
		sliding: false,

		/**
		 * Enabled checkboxes.
		 *
		 * @type {Object}
		 */
		checkboxes: {
			margin: [],
			padding: [],
			borderWidth: [],
			borderRadius: [],
		},

		/**
		 * Indexes of css string value (10px 10px 10px 10px)
		 * sides when split into an array.
		 *
		 * @type {Object}
		 */
		indexes: { top: 0, right: 1, bottom: 2, left: 3 },

		/**
		 * On inspector style changes, save new css styles for selected
		 * element and make them undoable/redoable.
		 *
		 * @param  string style
		 * @param  mixed  newValue
		 * @param  mixed  oldValue
		 *
		 * @return void
		 */
		applyCss: function(style, newValue, oldValue) {
			var isObject = angular.isObject(newValue);

			//bail if no or incorrect values passed
			if (! newValue || oldValue === newValue) return true;

			//make sure we get object value and not reference
			var oldVal = isObject ? $.extend({}, oldValue) : oldValue;
			var newVal = isObject ? $.extend({}, newValue) : newValue;

			if ($rootScope.selected.path && ! $scope.selecting) {
				css.add(null, style, newVal, oldVal);
			}

			//make style change undoable, only if it's not changed via slider
			//as that would create a command for every pixel change
			if ($rootScope.selected && $rootScope.selected.path && ! inspector.sliding && ! $scope.selecting) {

				$rootScope.repositionBox('select');
				$rootScope.hoverBox.hide();

				undoManager.add('revertStyles', {
					property: style,
					oldStyles: oldVal,
					newStyles: newVal,
					node: $rootScope.selected.node,
					path: $rootScope.selected.path,
				});
			}
		},

		/**
		 * Toggle which directions will inspector slider affect.
		 *
		 * @param  string style
		 * @param  string dir
		 *
		 * @return void
		 */
		toggleStyleDirections: function(prop, dir) {

			//toggle all direction if we get passed 'all'
			if (dir == 'all') {
				if (this.checkboxes[prop].length >= 4) {
					this.checkboxes[prop].length = 0;
				} else {
					if (prop == 'borderRadius') {
						this.checkboxes[prop].push('topRight', 'topLeft', 'bottomRight', 'bottomLeft');
					} else {
						this.checkboxes[prop].push('top', 'bottom', 'right', 'left');
					}
				}

				return $rootScope.$broadcast(prop+'.directions.changed');
			}

			var i = this.checkboxes[prop].indexOf(dir);

			if (i != -1) {
				this.checkboxes[prop].splice(i, 1);
			} else {
				this.checkboxes[prop].push(dir);
			}

			$rootScope.$broadcast(prop+'.directions.changed');
		},

		/**
		 * Clear any stored styles on the inspector.
		 *
		 * @return void
		 */
		clearStyles: function() {
			for (var key in this.styles) {
				for (var prop in this.styles[key]) {
					if (! /(^_)/.test(prop) && prop !== 'property') {
						this.styles[key][prop] = null;
					}
			 	}
			}
		},

		/**
		 * Change existing css style on inspector to new one.
		 *
		 * @param  string  prop    'border'
		 * @param  string  attr    'width'
		 * @param  array   sides   ['top', 'right']
		 * @param  string  value   10px
		 * @param  string  append  px
		 *
		 * @return void
		 */
		changeStyle: function(prop, attr, sides, value, append) {

			//get a referance to style property on inspector
			if ( ! attr) {
				var property = this.styles[prop];
			} else {
				var property = this.styles[prop][attr];
			}

			//bail if no value or invalid params
			if (angular.isUndefined(property) || ! value) return true;

			//loop trough passed in value sides and replace them in
			//the old value string with the new value
			if (angular.isObject(property)) {

				for (var i = sides.length - 1; i >= 0; i--) {
					property[sides[i]] = append?value+append:value;
				}
			} else {
				var oldValue = property.split(' ');

				for (var i = sides.length - 1; i >= 0; i--) {
					oldValue[this.indexes[sides[i]]] = append?value+append:value;
				};

				this.styles[prop][attr] = oldValue.join(' ');
			}
		},

		applySliderValue: function(name, value, append) {

			if (name == 'borderWidth') {
				var prop = this.styles.border.width;
			} else if (name == 'borderRadius') {
				var prop = this.styles.border.radius;
			} else {
				var prop = this.styles[name];
			}

			//apply new value to the padding sides that are selected by user
			for (var i = this.checkboxes[name].length - 1; i >= 0; i--) {
				prop[this.checkboxes[name][i]] = append ? value+append : value;
			}

			if ($rootScope.selected.path && ! $scope.selecting) {
				css.add(false, name, prop, false, true);
			}
		},

		applyInputBoxValue: function(name, value, dir, append) {
			var old = css.getValueFor($rootScope.selected.selector, name);

			this.styles[name][dir] = value.replace(/[A-Za-z]/g, '')+'px';

			if ($rootScope.selected.path && ! $scope.selecting) {
				css.add(false, name, this.styles[name], old);
			}

			if ($rootScope.selected.path && ! inspector.sliding && ! $scope.selecting) {
				undoManager.add('revertStyles', {
					property: name,
					oldStyles: old,
					newStyles: $.extend({}, this.styles[name]),
					path: $rootScope.selected.path.slice(0),
				});
			}

			$rootScope.repositionBox('select');
		},

		applyBigInputBoxValue: function(name, value, append) {
			var old = css.getValueFor($rootScope.selected.selector, name);
				val = value.replace(/[A-Za-z]/g, '')+'px';

			this.styles[name] = {top: val, left: val, right: val, bottom: val};

			if ($rootScope.selected.path && ! $scope.selecting) {
				css.add(false, name, this.styles[name], old);
			}

			$rootScope.repositionBox('select');
		},

		styles: {
			padding: {},
			margin: {},
			border: {},
			color: {},
			attributes: {
				class: [],
				id: '',
				float: '',
			},
			text: {},
		}

	};

	return inspector;
}])

.directive('blPrettyScrollbar', function() {
    return {
        restrict: 'A',
        compile: function(el) {
            el.mCustomScrollbar({
            	theme: 'light-thin',
            	scrollInertia: 300,
            	autoExpandScrollbar: false,
            	autoHideScrollbar: true
            });
        }
   	}
})

.directive('blPrettySelect', ['$parse', '$rootScope', function($parse, $rootScope) {

    //extend jquery ui widget so we can use different
    //styles for every select option
    $.widget('builder.prettyselect', $.ui.selectmenu, {
        _renderItem: function(ul, item) {
            var li = $('<li>', {text: item.label});

            //grab any styles stored on options and apply them
            $.each(item.element.data(), function(i,v) {
                li.css(i, v);
            });

            return li.appendTo(ul);
        }
    });

    return {
        restrict: 'A',
        link: function($scope, el, attrs) {

            //initiate select plugin on element
            el.prettyselect({
                width: attrs.width ? attrs.width : 100,
                appendTo: attrs.appendTo ? attrs.appendTo : $rootScope.inspectorCont
            });

            //hide select menu on inspector scroll
            $scope.inspectorCont.on('scroll', function() {
                el.prettyselect('close');
            });

            //get object reference to bind select value to
            var model = $parse(attrs.blPrettySelect);

            //assign new value to object on the scope we got above
            el.on('prettyselectchange', function(e, ui) {

                $scope.$apply(function() {
                    model.assign($scope, ui.item.value);
                });
            });

            //set up two way binding between select and model we got above
            $scope.$watch(attrs.blPrettySelect, function(elVal) {
                if ( ! elVal) { return true; };

                for (var i = el.get(0).options.length - 1; i >= 0; i--) {
                    var selVal = el.get(0).options[i].value.removeQoutes();

                    if (selVal == elVal || selVal.match(new RegExp('^.*?'+elVal+'.*?$'))) {
                        return el.val(selVal).prettyselect('refresh');
                    }
                }
            });
        }
    }
}])

.directive('wstInspector', function($compile,icons,c3Charts,$rootScope,textStyles,$window) {
return {
    transclude: true,
    scope: {
        onChange: '=',
        description: '@',
        element: '=',
        properties: '=',
        dashboard: '=',
        wstMode: '@'
    },

    templateUrl: "partials/widgets/inspector.html",

    // append
    replace: true,
    // attribute restriction
    restrict: 'E',
    // linking method
    link: function($scope, element, attrs) {

      $scope.textStyles = textStyles;

      $("#bkg-color").spectrum({
    flat: true,
    showInput: true
});


      //$scope.inspector = inspector;

      $scope.textures = new Array(28);

      $scope.gradients = [
      		'linear-gradient(to right, #959595 0%, #0D0D0D 46%, #010101 50%, #0A0A0A 53%, #4E4E4E 76%, #383838 87%, #1b1b1b 100%)',
      		'linear-gradient(to right, #FF0000 0%, #FFFF00 50%, #ff0000 100%)',
      		'linear-gradient(to right, #f6f8f9 0%, #E5EBEE 50%, #D7DEE3 51%, #f5f7f9 100%)',
      		'linear-gradient(to right, #008080 0%, #FFFFFF 25%, #05C1FF 50%, #FFFFFF 75%, #005757 100%)',
      		'linear-gradient(to right, #ff0000 0%, #000000 100%)',
      		'linear-gradient(to bottom, #93cede 0%,#75bdd1 41%, #49a5bf 100%)',
      		'linear-gradient(to right, #f8ffe8 0%, #E3F5AB 33%, #b7df2d 100%)',
      		'linear-gradient(to right, #b8e1fc 0%, #A9D2F3 10%, #90BAE4 25%, #90BCEA 37%, #90BFF0 50%, #6BA8E5 51%, #A2DAF5 83%, #bdf3fd 100%)',
      		'linear-gradient(to right, #f0b7a1 0%, #8C3310 50%, #752201 51%, #bf6e4e 100%)',
      		'linear-gradient(to right, #ff0000 0%, #FFFF00 25%, #05C1FF 50%, #FFFF00 75%, #ff0000 100%)',
      		'linear-gradient(to right, #ffb76b 0%, #FFA73D 50%, #FF7C00 51%, #ff7f04 100%)',
      		'linear-gradient(to right, #ffff00 0%, #05C1FF 50%, #ffff00 100%)',
      		'linear-gradient(to bottom, #febf01 0%,#febf01 100%)',
      		'linear-gradient(to bottom, #fcfff4 0%,#e9e9ce 100%)',
      		'linear-gradient(to bottom, #49c0f0 0%,#2cafe3 100%)',
      		'linear-gradient(to bottom, #cc0000 0%,#cc0000 100%)',
      		'linear-gradient(to bottom, #73880a 0%,#73880a 100%)',
      		'linear-gradient(to bottom, #627d4d 0%,#1f3b08 100%)',
      		'linear-gradient(to bottom, #b8c6df 0%,#6d88b7 100%)',
      		'linear-gradient(to bottom, #9dd53a 0%,#a1d54f 50%,#80c217 51%,#7cbc0a 100%)',
      		'linear-gradient(to bottom, #b8c6df 0%,#6d88b7 100%)',
      		'linear-gradient(to bottom, #ff3019 0%,#cf0404 100%)',
      		'linear-gradient(to bottom, #e570e7 0%,#c85ec7 47%,#a849a3 100%)',
      		'linear-gradient(to bottom, #ffffff 0%,#f3f3f3 50%,#ededed 51%,#ffffff 100%)',
      	];



      $scope.canEdit = function(block)
      {
        result = true;
        return result;
      }

      $scope.inspector = {styles: {
                              height: 100,
															source: '',
															headingType: '',
                        			padding: {},
                        			margin: {},
                        			border: {},
                        			color: {},
                        			attributes: {
                        				class: [],
                        				id: '',
                        				float: '',
                        			},
                        			text: {},
                        		}
                          };

      $scope.previews = {
    		image: $('#image'),
    		gradient: $('#gradient'),
    		color: $('#fill-color'),
    	};

      $scope.properties = {
    		image: false,
    		position: 'center center',
    		repeat: 'repeat',
    		color: false,
    	};

			$scope.openImageGallery = function(target) {
					$rootScope.openGalleryModal(function(url) {
							$scope.setBackgroundImage(url);
					});
			};

			$scope.setBackgroundImage = function(url){
	        $scope.backgroundImage = url;

	        if ($scope.selectedElement) {
	            var theElement = $scope.selectedElement;

	            if ($scope.backgroundImage != undefined &&  $scope.backgroundImage != 'none') {

	                theElement.css({ 'background-image': "url('"+$scope.backgroundImage+"')" });
	                theElement.css({ '-webkit-background-size': 'cover'});
	                theElement.css({ '-moz-background-size': 'cover'});
	                theElement.css({ '-o-background-size': 'cover'});
	                theElement.css({ 'background-size': 'cover'});
	            } else {
	                theElement.css({ 'background-image': 'none' });
	            }

	            if ($scope.dashboard) {
	                if ($scope.backgroundImage != undefined &&  $scope.backgroundImage != 'none')
	                    $scope.dashboard.backgroundImage = $scope.backgroundImage;
	                else
	                    $scope.dashboard.backgroundImage = 'none';
	            }
	        }
	    };

      $scope.$on('element.reselected', function(e, node) {
      	$scope.selecting = true;
        $scope.selectedElement = node;

        var pos = node[0].getBoundingClientRect();

        var elementTop = pos.top-2;//pos.top-57;
        var elementLeft = pos.left-2;
        var elementWidth = pos.width+4;
        var elementHeight = pos.height+4;


        $('#select-box').css('top',elementTop);
        $('#select-box').css('left',elementLeft);
        $('#select-box').css('width',elementWidth);
        $('#select-box').css('height',elementHeight);

        $('#select-box').show();

        $scope.properties.image = node.css('background-image');
            $('#image').css('background-image',$scope.properties.image);
            $('#gradient').css('background-image','none');
    		$scope.properties.color = node.css('background-color');
            $('#fill-color').css('background-color',$scope.properties.color);
        $scope.inspector.styles.text.color = node.css('color');
  			$scope.inspector.styles.text.fontSize = node.css('font-size');
  			$scope.inspector.styles.text.textAlign = node.css('text-align');
  			$scope.inspector.styles.text.fontStyle = node.css('font-style');
  			$scope.inspector.styles.text.fontFamily = node.css('font-family');
  			$scope.inspector.styles.text.lineHeight = node.css('line-height');
  			$scope.inspector.styles.text.fontWeight = node.css('font-weight');
  			$scope.inspector.styles.text.textDecoration = node.css('text-decoration');
        $scope.inspector.styles.border.border = node.css('text-decoration');
        $scope.inspector.styles.height = node.css('height');
        $scope.inspector.styles.padding.top = node.css('padding-top');
        $scope.inspector.styles.padding.left = node.css('padding-left');
        $scope.inspector.styles.padding.right = node.css('padding-right');
        $scope.inspector.styles.padding.bottom = node.css('padding-bottom');
          if ($scope.inspector.styles.padding.top == $scope.inspector.styles.padding.left && $scope.inspector.styles.padding.top == $scope.inspector.styles.padding.right && $scope.inspector.styles.padding.top == $scope.inspector.styles.padding.bottom)
            $scope.paddingAll = $scope.inspector.styles.padding.top;
            else {
            $scope.paddingAll = '';
            }
        $scope.inspector.styles.margin.top = node.css('margin-top');
        $scope.inspector.styles.margin.left = node.css('margin-left');
        $scope.inspector.styles.margin.right = node.css('margin-right');
        $scope.inspector.styles.margin.bottom = node.css('margin-bottom');
          if ($scope.inspector.styles.margin.top == $scope.inspector.styles.margin.left && $scope.inspector.styles.margin.top == $scope.inspector.styles.margin.right && $scope.inspector.styles.margin.top == $scope.inspector.styles.margin.bottom)
            $scope.marginAll = $scope.inspector.styles.margin.top;
            else {
            $scope.marginAll = '';
            }
        $scope.inspector.styles.border.top = node.css('border-top-width');
        $scope.inspector.styles.border.left = node.css('border-left-width');
        $scope.inspector.styles.border.right = node.css('border-right-width');
        $scope.inspector.styles.border.bottom = node.css('border-bottom-width');
          if ($scope.inspector.styles.border.top == $scope.inspector.styles.border.left && $scope.inspector.styles.border.top == $scope.inspector.styles.border.right && $scope.inspector.styles.border.top == $scope.inspector.styles.border.bottom)
            $scope.borderAll = $scope.inspector.styles.border.top;
            else {
            $scope.borderAll = '';
            }
        $scope.inspector.styles.border.color = node.css('border-color');
            $('#border-color').css('border-color',$scope.inspector.styles.border.color);
        $scope.inspector.styles.border.style = node.css('border-style');

        $scope.inspector.styles.border.radiusTopLeft = node.css('border-top-left-radius');
        $scope.inspector.styles.border.radiusTopRight = node.css('border-top-right-radius');
        $scope.inspector.styles.border.radiusBottomLeft = node.css('border-bottom-left-radius');
        $scope.inspector.styles.border.radiusBottomRight = node.css('border-bottom-right-radius');
          if ($scope.inspector.styles.border.radiusTopLeft == $scope.inspector.styles.border.radiusTopRight && $scope.inspector.styles.border.radiusTopLeft == $scope.inspector.styles.border.radiusBottomLeft && $scope.inspector.styles.border.radiusTopLeft == $scope.inspector.styles.border.radiusBottomRight)
            $scope.inspector.styles.border.radius = $scope.inspector.styles.border.radiusTopLeft;
            else {
            $scope.inspector.styles.border.radius = '';
            }

        //$scope.elementType = $rootScope.elementType;
        $scope.elementType = node.attr('ndType');

				if ($scope.elementType == 'image' || $scope.elementType == 'video')
				{
					//.setAttribute("ng-click", "function_name()");
 					$scope.inspector.styles.source = node.attr('src');
				}
				if ($scope.elementType == 'heading')
				{
					if (node.is("h1"))
						$scope.inspector.styles.headingType = 'h1';
						if (node.is("h2"))
							$scope.inspector.styles.headingType = 'h2';
							if (node.is("h3"))
								$scope.inspector.styles.headingType = 'h3';
								if (node.is("h4"))
									$scope.inspector.styles.headingType = 'h4';
									if (node.is("h5"))
										$scope.inspector.styles.headingType = 'h5';
										if (node.is("h6"))
											$scope.inspector.styles.headingType = 'h6';

				}


        $scope.$apply();

        setTimeout(function() {
          $scope.selecting = false;
        }, 500);
    	});

      $scope.applyBigInputBoxValue = function(name, value, append) {
  				   val = value.replace(/[A-Za-z]/g, '')+'px';
  			     $scope.inspector.styles[name] = {top: val, left: val, right: val, bottom: val};
  		};

      $scope.selectPreset = function(e) {
      		if (e) {
      			$scope.properties.image = $(e.target).css('background-image');
      		}
      	};

				$scope.$watchCollection('inspector.styles.source', function(newProps, oldProps) {
	      		if (! $scope.selecting && ! $scope.dragging) {
							    $scope.selectedElement.attr('src',newProps);
						}
					});
					$scope.$watchCollection('inspector.styles.headingType', function(newProps, oldProps) {
							if (! $scope.selecting && ! $scope.dragging) {
								var html = '<'+newProps+' page-block ndtype="heading" class="editable">' + $scope.selectedElement[0].innerHTML + '</'+newProps+'>';
								var $div = $(html);

				            angular.element(document).injector().invoke(function($compile) {
				                var scope = angular.element($div).scope();
				                $compile($div)($scope);
				            });


								$scope.selectedElement.replaceWith($div);
								repositionSelectBox();
							}
				});

				$scope.moveElementUp = function()
		    {
		       var theElement = $scope.selectedElement;

		       var selected = $(theElement).index();

		       var parent = $(theElement).parent();

		       $(parent).children().eq(selected-1).before($(parent).children().eq(selected));
					 repositionSelectBox();
		    }

		    $scope.moveElementDown = function()
		    {
		       var theElement = $scope.selectedElement;

		       var selected = $(theElement).index();

		       var parent = $(theElement).parent();

		       $(parent).children().eq(selected+1).after($(parent).children().eq(selected));
					 repositionSelectBox();
		    }

      $scope.$watchCollection('properties', function(newProps, oldProps) {
      		if (! $scope.selecting && ! $scope.dragging) {
      			for(var prop in newProps) {
      				if (newProps[prop] && newProps[prop] !== oldProps[prop]) {

      					//handle previews in inspector - image
      					if (newProps[prop].indexOf('url') > -1) {
      						$scope.previews.image.css('background-image', newProps[prop]);
      					//gradient
      					} else if (newProps[prop].indexOf('gradient') > -1) {
      						$scope.previews.gradient.css('background-image', newProps[prop]);
      					//fill color
      					} else {
      						if (newProps[prop] && newProps[prop] != 'transparent' && newProps[prop] !== 'rgba(0, 0, 0, 0)') {
      							$scope.previews.color.css('background', newProps[prop]);
      						} else {
      							$scope.previews.color.css('background', 'url("'+$scope.baseUrl+'images/transparent.png")');
      						}
      					}

      					//use background instead of background-color so background image will get overwritten
      					var style = prop == 'color' ? 'background' : 'background-'+prop;
                  $scope.selectedElement.css(style,newProps[prop]);
      				 //MENE inspector.applyCss(style, newProps[prop], oldProps[prop]);
      				}
      			}
      		}
      	});

        $scope.$watchCollection('inspector.styles.text', function(newProps, oldProps) {

        		if (! $scope.selecting && ! $scope.dragging) {
        			for(var prop in newProps) {
        				if (newProps[prop] && newProps[prop] !== oldProps[prop]) {

                    $scope.selectedElement.css(prop,newProps[prop]);
                    repositionSelectBox();
                }
              }
            }
        });

        $scope.$watchCollection('inspector.styles.height', function(newProps, oldProps) {

        		if (! $scope.selecting && ! $scope.dragging) {
        				if (newProps && newProps !== oldProps) {

                    val = newProps.replace(/[A-Za-z]/g, '')+'px';
                    $scope.selectedElement.css('height',val);
                    repositionSelectBox();
                }

            }
        });

        $scope.$watchCollection('inspector.styles.padding', function(newProps, oldProps) {
          	if (! $scope.selecting && ! $scope.dragging) {
              var top = '0px';
              var right = '0px';
              var bottom = '0px';
              var left = '0px';
        			for(var prop in newProps) {
        				if (newProps[prop]) {

                  if (prop == 'top')
                     top = newProps[prop];
                  if (prop == 'right')
                    right = newProps[prop];
                  if (prop == 'bottom')
                      bottom = newProps[prop];
                  if (prop == 'left')
                      left = newProps[prop];

                }
              }

              var styleVal = top + ' '+ right+' '+bottom+' '+left;
              $scope.selectedElement.css('padding',styleVal);

              repositionSelectBox();
            }
        });

        $scope.$watchCollection('inspector.styles.margin', function(newProps, oldProps) {
          	if (! $scope.selecting && ! $scope.dragging) {
              var top = '0px';
              var right = '0px';
              var bottom = '0px';
              var left = '0px';
        			for(var prop in newProps) {

                if (newProps[prop]) {

                  if (prop == 'top')
                     top = newProps[prop];
                  if (prop == 'right')
                    right = newProps[prop];
                  if (prop == 'bottom')
                      bottom = newProps[prop];
                  if (prop == 'left')
                      left = newProps[prop];

                }
              }

          //  top right  bottom  left
              var styleVal = top + ' '+ right+' '+bottom+' '+left;
              $scope.selectedElement.css('margin',styleVal);

              repositionSelectBox();
            }
        });

        $scope.$watchCollection('inspector.styles.border', function(newProps, oldProps) {
          	if (! $scope.selecting && ! $scope.dragging) {

              var top = '0px';
              var right = '0px';
              var bottom = '0px';
              var left = '0px';


              for(var prop in newProps) {

                if (newProps[prop]) {

                  if (prop == 'top')
                     top = newProps[prop];
                  if (prop == 'right')
                    right = newProps[prop];
                  if (prop == 'bottom')
                      bottom = newProps[prop];
                  if (prop == 'left')
                      left = newProps[prop];
                  if (prop == 'color')
                      $scope.selectedElement.css('border-color',newProps[prop]);
                  if (prop == 'style')
                      $scope.selectedElement.css('border-style',newProps[prop]);


                }
              }
            }

            var styleVal = top + ' '+ right+' '+bottom+' '+left;
            $scope.selectedElement.css('border-width',styleVal);
              repositionSelectBox();
            });

          $scope.$watchCollection('inspector.styles.border.radius', function(newProps, oldProps) {
            	if (! $scope.selecting && ! $scope.dragging) {
                        $scope.selectedElement.css('border-radius',newProps);
                        $scope.selectedElement.css('border-top-left-radius',newProps);
                        $scope.selectedElement.css('border-top-right-radius',newProps);
                        $scope.selectedElement.css('border-bottom-left-radius',newProps);
                        $scope.selectedElement.css('border-bottom-right-radius',newProps);
                        $scope.inspector.styles.border.radiusTopLeft = $scope.inspector.styles.border.radius;
                        $scope.inspector.styles.border.radiusTopRight = $scope.inspector.styles.border.radius;
                        $scope.inspector.styles.border.radiusBottomLeft = $scope.inspector.styles.border.radius;
                        $scope.inspector.styles.border.radiusBottomRight = $scope.inspector.styles.border.radius;
                }


          repositionSelectBox();
        });

        $scope.$watchCollection('inspector.styles.border.radiusTopLeft', function(newProps, oldProps) {
            if (! $scope.selecting && ! $scope.dragging) {
                  $scope.selectedElement.css('border-top-left-radius',newProps);
              }


        repositionSelectBox();
        });

        $scope.$watchCollection('inspector.styles.border.radiusTopRight', function(newProps, oldProps) {
            if (! $scope.selecting && ! $scope.dragging) {
                  $scope.selectedElement.css('border-top-right-radius',newProps);
              }


        repositionSelectBox();
        });

        $scope.$watchCollection('inspector.styles.border.radiusBottomLeft', function(newProps, oldProps) {
            if (! $scope.selecting && ! $scope.dragging) {
                  $scope.selectedElement.css('border-bottom-left-radius',newProps);
              }


        repositionSelectBox();
        });

        $scope.$watchCollection('inspector.styles.border.radiusBottomRight', function(newProps, oldProps) {
            if (! $scope.selecting && ! $scope.dragging) {
                  $scope.selectedElement.css('border-bottom-right-radius',newProps);
              }


        repositionSelectBox();
        });


        $scope.deleteSelected = function()
        {


            var elementID = $scope.selectedElement.attr('id');

            if ($scope.elementType == 'tabsContainer')
                {
                  /*
                var containerNbr = -1;

                for (var c in $scope.selectedDashboard.containers)
                    if ($scope.selectedDashboard.containers[c].id == elementID)
                        containerNbr = c;

                if (containerNbr > -1)
                   $scope.selectedDashboard.containers.splice(containerNbr,1);
*/
                }
            $scope.selectedElement.remove();
            $('#select-box').hide();
        }

        angular.element($window).bind('resize', function(){

         repositionSelectBox()

         // manuall $digest required as resize event
         // is outside of angular
         $scope.$digest();
       });

       angular.element($window).bind("scroll", function() {
         repositionSelectBox()

         // manuall $digest required as resize event
         // is outside of angular
         scope.$digest();
        });


        function repositionSelectBox()
        {
          var pos = $scope.selectedElement[0].getBoundingClientRect();

          var elementTop = pos.top-2;
          var elementLeft = pos.left-2;
          var elementWidth = pos.width+4;
          var elementHeight = pos.height+4;

          $('#select-box').css('top',elementTop);
          $('#select-box').css('left',elementLeft);
          $('#select-box').css('width',elementWidth);
          $('#select-box').css('height',elementHeight);
        }

    }

  }

})

.directive('blPanelsAccordion', function() {
    return {
        restrict: 'A',
        link: function($scope, el) {
            el.on('click', '.accordion-heading', function(e) {
                var item = $(e.target).closest('.accordion-item');

                if (item.hasClass('open')) {
                    el.find('.accordion-item').removeClass('open');
                } else {
                    el.find('.accordion-item').removeClass('open');
                    $scope.$apply(function() {
                        item.addClass('open');
                    });
                }
            });
        }
    }
})

.directive('blElementVisibilityControls', function() {
    return {
   		restrict: 'A',
      	link: function($scope, el) {
      		var list = $('#visibility li');

      		//when a new element is selected reflect it's bootstrap 'hidden'
      		//classes in the inspector
      		$scope.$on('element.reselected', function(e) {
      			//MENE var classes = $scope.selected.node.className || '';
/*
      			list.each(function(i, item) {
      				if (classes.indexOf('hidden-'+item.dataset.size) > -1) {
      					item.className = 'disabled';
      				} else {
      					item.className = '';
      				}
      			})
            */
      		});

      		//on click add/remove 'hidden-x' class to currently selected element
      		el.on('click', 'li', function(e) {
      			var li = $(e.currentTarget);
      			var size = li.data('size');

      			if (li.hasClass('disabled')) {
      				$($scope.selected.node).removeClass('hidden-'+size);
      				li.removeClass('disabled');
      			} else {
      				$($scope.selected.node).addClass('hidden-'+size);
      				li.addClass('disabled');
      			}

      			$scope.$emit('builder.html.changed');
  				$scope.repositionBox('select');
      		});
      	}
    };
})
/*
.directive('blColorPicker', ['$parse', '$rootScope', 'inspector', function($parse, $rootScope, inspector) {

    return {
        restrict: 'A',
        link: function($scope, el) {

            //create an input element to instantiate color picker on
            var input = $('<input id="color-picker"/>').prependTo(el);

            //initiate color picker with some predefined colors to choose from
            input.spectrum({
                flat: true,
                palette: colorsForPicker,
                showAlpha: true,
                showPalette: true,
                showInput: true
            });

            //cache values needed for color picker repositioning
            var container  = $('#inspector .sp-container'),
                triggers   = $('.color-picker-trigger'),
                contHeight = container.height(),
                arrow      = $('#color-picker-arrow'),
                bottomEdge = $('#viewport').height();

            $rootScope.colorPickerCont = container.add(arrow).addClass('hidden');

            container.find('.sp-choose').on('click', function(e) {
                $rootScope.colorPickerCont.addClass('hidden');
                return false;
            });

            triggers.on('click', function(e) {
                var top   = $(e.target).offset().top + (e.currentTarget.offsetHeight/2 - 15),
                    model = e.currentTarget.dataset.controls,
                    scope = angular.element(e.currentTarget).scope();

                if ( ! $scope.colorProperty || $scope.colorProperty == model) {
                    $rootScope.colorPickerCont.toggleClass('hidden');
                }

                //hide image/gradient panel
                $('#background-flyout-panel').addClass('hidden');
                $('#background-arrow').hide();

                input.off('move.spectrum').on('move.spectrum', function(e, color) {

                    var rgb = color.toRgb();

                    //if transparency is 0 or 1 convert to hex
                    //format otherwise convert to rgba format
                    if (rgb.a === 0 || rgb.a === 1) {
                        color = color.toHexString();
                    } else {
                        color = color.toRgbString();
                    }

                    //write current color on inspector so we have real time
                    //reflection on element in the DOM
                    scope.$apply(function() {
                        $parse(model).assign(scope, color);
                    });
                });

                var tempTop = top - contHeight/2 + 10;

                //position picker 15px above bottom edge if not enough space normally
                if (bottomEdge < (tempTop + contHeight)) {
                    tempTop = bottomEdge - contHeight - 15;
                }

                //position picker 15px below top edge if not enough space normally
                if (tempTop < 0) {
                    tempTop = 15;
                }

tempTop = top;
tempLeft =
                container.css('top', tempTop);
                container.css('left',tempLeft);

                arrow.css({
                    display: 'block',
                    left: 309,
                    top:  top
                });

                input.spectrum('set', $parse(model)(scope));

                //set trigger as previous and grab color propperty (background, border-color etc)
                //from targets data attribute so we know what we should apply colors to
                $scope.colorProperty = e.currentTarget.dataset.controls;
                inspector.styles.color.property = $scope.colorProperty;
            });

            //create the command to undo color change on dragstart
            input.on("dragstart.spectrum", function(e, color) {
                inspector.sliding = true;
                $scope.$broadcast($scope.colorProperty+'.slidestart', 'color');
            });

            //add the command to undo manager on dragstop
            input.on("dragstop.spectrum", function() {
                inspector.sliding = false;
                $scope.$broadcast($scope.colorProperty+'.slidestop', 'color');
            });
        }
    }

}])

*/

.directive('blShowImgContainer', ['$timeout', function($timeout) {
	return {
		restrict: 'A',
		link: function($scope, el, attrs, controller) {
			var list = $('#background-flyout-panel'),
				arrow = $('#background-arrow'),
				presets = { texture: $('#texturePresets'), gradient: $('#gradientPresets') };

			var togglePresetCont = function(name) {
				presets.texture.hide();
				presets.gradient.hide();

				if (name == 'image') name = 'texture';

				presets[name].show();
			};

			//hide panel on X click in the header
			list.find('.bl-panel-btns').on('click', function(e) {
				list.addClass('hidden');
				arrow.hide();
			});

			//on gradient or texture click in inspector position and show fly out pane
			el.on('click', function(e) {
				var offset = $(e.currentTarget).offset().top;
				list.removeClass('hidden');
				togglePresetCont(e.currentTarget.id);
				arrow.css('top', offset+12).show();

                var offsetTop = offset-(list.height()/2)+40;

                if (offsetTop < 1) {
                    offsetTop = 5;
                }

                list.css('top', offsetTop);

				//hide color picker container if exists
				if ($scope.colorPickerCont) {
					$scope.colorPickerCont.addClass('hidden');
				}
			});
		}
	};
}])

.directive('blRangeSlider', ['$rootScope', '$parse', 'inspector', function($rootScope, $parse, inspector) {

	return {
		restrict: 'A',
		link: function($scope, el, attrs) {
			var model = $parse(attrs.blRangeSlider);

			//initiate slider
			el.slider({
				min: 0,
		    	step: 1,
		    	max: attrs.max ? attrs.max : 100,
		      	range: "min",
		      	animate: true,
		    	slide: function(e, ui) {
		    		if (attrs.blRangeSlider.indexOf('props') > -1) {
		    			$scope.$apply(function() { model.assign($scope, ui.value); });
		    		} else {
		    			inspector.applySliderValue(attrs.blRangeSlider, ui.value, 'px');
		    		}

		    	}
		    });

			//reset slider when user selects a different DOM element or different
			//style directions (top, bot, left, right)
			$scope.$on('element.reselected', function() { el.slider('value', 0) });
			$scope.$on(attrs.blRangeSlider+'.directions.changed', function() { el.slider('value', 0) });

			el.on("slidestart", function(event, ui) {
				inspector.sliding = true;
				$scope.$broadcast(attrs.blRangeSlider.replace(/[A-Z][a-z]+/g, '')+'.slidestart', attrs.blRangeSlider);

				//hide select and hover box while user is dragging
				//as their positions will get messed up
				//MENE $scope.selectBox.add($scope.hoverBox).hide();
			});

			el.on("slidestop", function(event, ui) {
				$scope.$broadcast(attrs.blRangeSlider.replace(/[A-Z][a-z]+/g, '')+'.slidestop', attrs.blRangeSlider);
				$scope.repositionBox('select');
				inspector.sliding = false;
				$rootScope.$broadcast('builder.css.changed');
			});
		}
	}
}])

.directive('blCheckboxes', ['$compile', function($compile) {
    return {
        restrict: 'A',
        link: function($scope, el, attrs) {
        	var p = attrs.blCheckboxes,
        		d = ['top', 'right', 'bottom', 'left'];

            var html = '<div class="pretty-checkbox pull-left">'+
			    '<input type="checkbox" id="'+p+'.all" ng-click="inspector.toggleStyleDirections(\''+p+'\', \'all\')">'+
			    '<label for="'+p+'.all"><span class="ch-all"></span><span class="unch-all"></span></label>'+
			'</div>'+
			'<div class="pull-right">';

			for (var i = 0; i < 4; i++) {
				html+= '<div class="pretty-checkbox">'+
				    '<input type="checkbox" id="'+p+'.'+d[i]+'" ng-click="inspector.toggleStyleDirections(\''+p+'\', \''+d[i]+'\')" ng-checked="inspector.checkboxes.'+p+'.indexOf(\''+d[i]+'\') !== -1">'+
				    '<label for="'+p+'.'+d[i]+'"><span class="ch-'+d[i]+'"></span><span class="unch-'+d[i]+'"></span></label>'+
				'</div>'
			};

			html+='</div>';

			el.html($compile(html)($scope));
        }
    }
}])

.directive('blInputBoxes', ['$compile', '$timeout', function($compile, $timeout) {
    return {
        restrict: 'A',
        link: function($scope, el, attrs) {
        	var p = attrs.blInputBoxes;

        	var html = '<div class="big-box col-sm-6">'+
				'<input ng-model="'+p+'All" ng-model-options="{ debounce: 300 }" ng-change="applyBigInputBoxValue(\''+p+'\', '+p+'All)">'+
			'</div>'+
			'<div class="small-boxes col-sm-6">'+
				'<div class="row">'+
					'<input ng-model="inspector.styles.'+p+'.top" ng-model-options="{ debounce: 300 }" ng-change="inspector.applyInputBoxValue(\''+p+'\', inspector.styles.'+p+'.top, \'top\')">'+
				'</div>'+
				'<div class="row">'+
					'<div class="col-sm-6">'+
						'<input ng-model="inspector.styles.'+p+'.left" ng-model-options="{ debounce: 300 }" ng-change="inspector.applyInputBoxValue(\''+p+'\', inspector.styles.'+p+'.left, \'left\')">'+
					'</div>'+
					'<div class="col-sm-6">'+
						'<input ng-model="inspector.styles.'+p+'.right" ng-model-options="{ debounce: 300 }" ng-change="inspector.applyInputBoxValue(\''+p+'\', inspector.styles.'+p+'.right, \'right\')">'+
					'</div>'+
				'</div>'+
				'<div class="row">'+
					'<input ng-model="inspector.styles.'+p+'.bottom" ng-model-options="{ debounce: 300 }" ng-change="inspector.applyInputBoxValue(\''+p+'\', inspector.styles.'+p+'.bottom, \'bottom\')">'+
				'</div>'+
			'</div>';

			el.html($compile(html)($scope));

			$scope.$on('element.reselected', function(e) {
				$timeout(function() {
					el.find('input').blur();
				}, 0, false);
			});
   		}
   	}
}])

.directive('blToggleTextDecoration', function() {
    return {
        restrict: 'A',
        link: function($scope, el, attrs) {
            el.on('click', function(e) {
            	var deco = attrs.blToggleTextDecoration,
            		scopeDeco = $scope.inspector.styles.text.textDecoration.trim();

            	$scope.$apply(function() {
            		//element has no text decoration currently so we'll just apply it now
            		if ( ! scopeDeco || scopeDeco.match(/^.*(none|initial).*$/)) {
            			$scope.inspector.styles.text.textDecoration = deco;

            		//element has given text decoration already so we'll remove it
            		} else if (deco == scopeDeco) {
            			$scope.inspector.styles.text.textDecoration = 'none';

            		//element has given text decoration as well as other decorations
            		//(underline overline) so we'll just remove given one and leave others intact
            		} else if (scopeDeco.match(deco)) {
            			$scope.inspector.styles.text.textDecoration = scopeDeco.replace(deco, '').trim();

            		//element has other text decorations but not this one so we'll append it to existing ones
            		} else {
            			$scope.inspector.styles.text.textDecoration += ' ' + deco;
            		}
            	});
            });
        }
    }
})

.directive('blToggleTextStyle', function() {
    return {
        restrict: 'A',
        link: function($scope, el, attrs) {
            el.on('click', function(e) {
            	var split = attrs.blToggleTextStyle.split('|');

            	$scope.$apply(function() {
            		if (el.hasClass('active')) {
	            		el.removeClass('active');
	            		$scope.inspector.styles.text[split[0]] = 'initial';
	            	} else {
	            		$scope.inspector.styles.text[split[0]] = split[1];
	            		el.addClass('active');

	            		if (split[1] != 'italic') {
	            			el.siblings().removeClass('active');
	            		}
	            	}
            	});
            });
        }
    }
})
